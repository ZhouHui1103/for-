# Linear-GitHub 集成工作流：从 Issue 到 Code 的自动化协作指南

### 引言：为何需要这套工作流？

本指南旨在为团队提供一套标准化的、深度集成 Linear 和 GitHub 的协作流程。目标是实现：

1.  **自动化**: 将繁琐的手动状态更新交给工具，让 Issue 状态真实反映代码状态。
2.  **守护心流**: 开发者可以专注于编码，无需频繁在 Linear 和 GitHub 之间切换上下文。
3.  **信息透明**: 任何人都可以通过一个 Linear Issue，完整追溯其相关的讨论、代码分支、代码审查（PR）和最终合并的全部历史。

我们将遵循 Linear 的核心哲学：**用结构化的沟通和自动化的节奏，取代混乱的计划和手动同步**。

---

## 核心工作流：一个 Issue 的生命周期

这个流程描绘了一项任务从诞生到完成的完整旅程，以及在此过程中 Linear 和 GitHub 如何无缝协作。

### 第1步：想法的诞生与汇集 (在 Linear)

*   **场景**: 任何团队成员（产品、开发、设计）发现了一个需求、一个 Bug 或一项技术债。
*   **动作**:
    1.  在 Linear 的 `Backlog` 中创建一个 `Issue`。
    2.  清晰地描述问题，如果可能，附上相关信息（如设计稿链接、用户反馈截图）。
*   **状态**: `Backlog`
*   **GitHub**: 此阶段无任何操作。
*   **哲学**: **鼓励多元与开放**。`Backlog` 是我们所有想法的蓄水池，确保没有好的想法会因为“时机不对”而被遗忘。

### 第2步：凝聚共识与做出承诺 (在 Linear)

这是将想法转化为可执行任务的关键一步，通常在两个核心会议中完成。

*   **场景一：待办事项梳理会 (Backlog Grooming)**
    *   **目标**: **达成共识**。
    *   **动作**: 团队共同讨论 `Backlog` 中的 `Issues`，进行澄清、补充细节、拆分或合并。至关重要的一步是：
        *   **评估复杂度 (`Estimate`)**: 团队成员（特别是执行者）对 `Issue` 进行点数评估（1, 2, 3, 5, 8...），评估的是**复杂度而非时间**。估点分歧是宝贵的对话机会，能暴露信息差，对齐认知。
        *   **识别依赖关系**: 如果 `Issue A` 依赖 `Issue B`，立即使用 `Issue Relations` 功能标记为 `Blocked by`。

*   **场景二：周期规划会 (Cycle Planning)**
    *   **目标**: **做出承诺**。
    *   **动作**: 基于团队的历史速率 (`Velocity`)，从已梳理好的 `Backlog` 中，选择最高优先级的 `Issues` 放入当前的 `Cycle`。
    *   **分配负责人 (`Assignee`)**。
*   **状态**: `Backlog` -> `Todo`
*   **GitHub**: 此阶段无任何操作。
*   **哲学**: **集体智慧与共同承诺**。通过讨论确保任务清晰可行，通过承诺确保目标现实且团队有拥有感。

### 第3步：开始开发 (从 Linear 到 GitHub)

*   **场景**: 开发者 `Alex` 准备开始处理分配给他的一个 `Issue`。
*   **动作**:
    1.  在 Linear 中，将该 `Issue` 的状态从 `Todo` 移动到 `In Progress`。
    2.  **关键操作**: 点击 `Issue` 详情页的 "**Create Branch**" 按钮。
        *   Linear 会自动为你创建一个与该 `Issue` 关联的 Git 分支，并遵循标准命名格式，例如 `alex/TEAM-123-implement-user-mention-feature`。
        *   将这个分支 `checkout`到本地，开始编码。
*   **状态**: `Todo` -> `In Progress`
*   **GitHub**: 自动创建了一个新的、与 Linear Issue 关联的分支。
*   **哲学**: **明确的信号与自动的关联**。状态变更告知所有人“工作已开始”。从 Linear 创建分支，则从源头上将代码与任务绑定，为后续自动化奠定基础。

### 第4步：提交审查 (从 GitHub 到 Linear)

*   **场景**: 开发者 `Alex` 完成了编码，并准备好让同事 `Ben` 进行代码审查。
*   **动作**:
    1.  `Alex` 在 GitHub 上创建一个 **Pull Request (PR)**。
    2.  **关键操作**: 在 PR 的描述中，**必须包含链接到 Linear Issue 的关键词**。例如：
        *   `Fixes TEAM-123`
        *   `Resolves TEAM-123`
        *   或者直接粘贴 Linear Issue 的 URL。
*   **状态 (自动变更)**: `In Progress` -> `In Review`
*   **GitHub**: PR 被创建，并与 Linear Issue 自动关联。你可以在 Linear Issue 页面直接看到对应的 PR 链接和状态（Open, Merged, Closed）。
*   **哲学**: **自动化、透明的反馈闭环**。当 PR 被创建，任务便自动进入审查状态。所有上下文（需求、代码）都汇集一处，审查者 `Ben` 无需询问背景，即可高效审查。

### 第5步：迭代与合并 (在 GitHub 和 Linear 之间)

*   **场景**: `Ben` 在审查后提出了一些修改意见。
*   **动作**:
    1.  `Ben` 在 GitHub PR 上留下评论并 `Request Changes`。
    2.  Linear 的 `Issue` 状态可以被配置为在 PR 收到修改请求时，自动从 `In Review` 回到 `In Progress`。（此为可选配置）
    3.  `Alex` 收到通知，进行修改，再次提交。
    4.  最终，`Ben` 批准了 PR。
    5.  `Alex` **在 GitHub 上合并 (Merge) 了这个 PR**。
*   **状态 (自动变更)**: `In Review` -> `Done`
*   **GitHub**: PR 被合并。
*   **哲学**: **让系统反映事实**。代码被合并到主干分支，意味着这项工作真正完成了。Linear 的状态自动更新，确保了信息永远是最新、最准确的，无需任何人手动同步。

---

## 总结：团队需遵守的黄金原则

1.  **所有工作始于 Linear Issue**: 杜绝任何没有 `Issue` 的临时性开发工作。
2.  **在 Linear 中规划，而非在聊天工具中**: 使用 `Cycles`, `Estimate` 和 `Issue Relations` 来进行结构化规划。
3.  **从 Linear 创建分支**: 这是实现自动关联的第一步，请务必使用 `Create Branch` 功能。
4.  **在 PR 描述中链接 Issue**: 这是触发自动化的核心，请务必使用 `Fixes` 等关键词。
5.  **信任自动化**: 相信工具会自动更新状态，开发者只需专注于“创建分支 -> 创建PR -> 合并PR”这一核心代码流程。

遵循这套流程，您的团队将能最大限度地利用 Linear 和 GitHub 的集成优势，创造一个高效、专注且愉悦的开发环境。

---

## 工作流背后的原理 (The "Why")

理解这套工作流为何如此设计，能帮助团队更好地内化规则，并在遇到问题时知道如何解决。这背后主要有两大原理：GitHub Flow 的协作模式，以及 Linear 与 GitHub 之间的自动化联动机制。

### 1. GitHub 的核心协作原理：GitHub Flow

我们采纳的工作流，本质上是业界广泛使用的 **GitHub Flow** 模型。它非常简洁，核心思想是保证 `main` 分支永远是稳定、可随时部署的。其步骤如下：

*   **原则一：`main` 分支是“真理之源”**
    *   任何在 `main` 分支上的代码，都应该是经过了审查、测试，并且可以随时部署到生产环境的。绝不允许直接向 `main` 分支提交代码。

*   **原则二：为新工作创建“特性分支” (Feature Branch)**
    *   当你开始一项新工作（无论是新功能还是 Bug 修复），你都必须从最新的 `main` 分支创建一个新的分支。例如 `feat/user-mention`。
    *   **这隔离了你的工作**。即使你的代码写到一半、甚至有错误，也完全不会影响到 `main` 分支的稳定性，其他同事的工作也不会被你干扰。

*   **原则三：“拉取请求” (Pull Request) 是沟通与审查的核心**
    *   当你的分支开发完成后，你不能直接将其合并回 `main` 分支。你需要创建一个 **Pull Request (PR)**。
    *   PR 的本质是一个**对话中心**。它在说：“嘿，我完成了这些代码，请大家帮忙看看有没有问题，如果没问题我就要把它合并进 `main` 分支了。”
    *   团队成员可以在 PR 里逐行评论代码、提出修改建议。这保证了**代码审查 (Code Review)** 制度的落地，是保障代码质量的关键环节。

*   **原则四：自动化守护质量 (CI/CD)**
    *   在 PR 被创建或更新时，可以自动触发一系列检查，例如：
        *   **运行自动化测试**: 确保你的修改没有破坏现有功能。
        *   **代码风格检查 (Linting)**: 保证代码风格一致。
        *   **构建 (Build)**: 确认项目可以成功编译。
    *   只有当所有检查都通过时，PR 才被允许合并。这构成了**持续集成 (Continuous Integration, CI)** 的基础。

*   **原则五：审查通过后“合并” (Merge)**
    *   当 PR 经过了同事的审查 (`Approve`) 并且所有自动化检查都通过后，你就可以将这个分支合并回 `main` 分支了。至此，你的代码才正式成为项目的一部分。

**总结**: GitHub Flow 通过“分支隔离开发 -> PR 集中审查 -> 自动化保障质量 -> 合并进入主干”这一系列结构化的流程，保证了多人协作开发软件的效率和质量。

### 2. Linear 与 GitHub 的联动“魔法”：Webhooks

Linear 和 GitHub 之间的自动化，并不是什么真正的魔法，而是通过一种名为 **Webhooks（网络钩子）** 的技术实现的。你可以把它理解成一个“事件通知系统”。

*   **第一步：授权与配置**
    *   当你将 Linear 应用授权给你的 GitHub 仓库时，Linear 会在 GitHub 那边“订阅”一系列它感兴趣的事件。比如：“当有新的 PR 被创建时，请通知我”、“当一个 PR 被合并时，也请通知我”。

*   **第二步：触发联动（以创建 PR 为例）**
    1.  **开发者在 GitHub 创建 PR**: `Alex` 创建了一个 PR，并在描述里写了 `Fixes TEAM-123`。
    2.  **GitHub 发现关键词并发起通知**: GitHub 在处理这个 PR 时，看到了 `Fixes TEAM-123` 这个关键词。它知道 `TEAM-123` 是一个外部系统（Linear）的 Issue 标识。
    3.  **GitHub 发送 Webhook**: GitHub 立刻向预先配置好的 Linear 的一个网址发送一个 HTTP 请求（这就是 Webhook）。这个请求里包含了所有信息，比如：“`Alex` 为仓库 `X-Silicon-Doc` 创建了一个 PR，标题是‘...’，它关联了 `TEAM-123`，目前状态是 `Open`。”
    4.  **Linear 接收并处理**: Linear 的服务器收到了这个通知，它解析了里面的信息，然后在其自己的数据库里，将 `TEAM-123` 这个 Issue 的状态从 `In Progress` 自动更新为 `In Review`，并将 PR 的链接附加上去。

*   **第三步：完成联动（以合并 PR 为例）**
    *   流程完全一样。当 `Alex` 的 PR 在 GitHub 上被合并时，GitHub 会再次向 Linear 发送一个 Webhook 通知：“嘿，那个关联了 `TEAM-123` 的 PR 刚刚被合并了！”
    *   Linear 收到这个通知后，便自动将 `TEAM-123` 的状态更新为 `Done`。

**总结**: 整个自动化的核心是 **GitHub 上的事件 (如 PR 创建/合并) -> Webhook 通知 -> Linear 接收通知并更新状态**。而这一切的起点，就是开发者在分支命名和 PR 描述中正确地引用了 Linear 的 Issue ID，这是让两个系统能够对话的“钥匙”。
